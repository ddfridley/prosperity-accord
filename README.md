__[demo]__ (http://react-action-state-path.herokuapp.com)
# react-action-state-path
A state and history management package for React for use when:
* components choose children dynamically based on user input
* the URL should update based on user actions and take a user back to where they left off
* the URL to a deep position should not be impossibly long and shouldn't contain sensitive stuff
* components have external information that needs to be fetched when restoring a deep URL
* users want the back and forward buttons of the browser to work
* components want send actions to parents or children (yes you can easially RESET children)
* parent state may change based on child actions
* you want to use something like the redux action -> state pattern to make code simplier to follow (it really does)

__If your working on one of those web sites that looses everyting I typed in when I hit the back button, THIS IS FOR YOU!__

The basic idea is, create a component with a __ReactActionStatePath__ component as its parent.  This is where the state information is saved, and this is where all the work is done for corrdinating with all the other RASP components, pushing and poping state to/from the browser history, updating the path, and disecting a new URL into path segments and getting each component to fetch it's external data and set it's state based on what's in the path.

Then in the component you are creating, there are two functions you need to supply:
1 _segmentToState_:  converts the path segment information generated by the component into state information.
2 _actionToState_: based on the action, and the current state, return the new state.

the __ReactActionStatePathClient__ base class provides these userful resources:
This component should be used when there will only be one 'active' child at a time. - Meaning that state and path from no more than on child will be saved/restored.
1 _this.toChild[]_ an array of all the child RASP components of this component. Actions can be sent to children with this.toChild[child-id](action) such as RESET_SHAPE
2 _toMeFromChild()_ which must be passed to children when created.

# Demo
http://react-action-state-path.herokuapp.com

This is a demo of nested text, like an outline.  The demo shows the root Article.  An article contains a subject and text and has an id and a parent id.  When you click on the subject an an Article, the text is shown, and the SubArticleList of Articles that have this as a parent is retrieved. When you click on the subject of a sub Article, the text and SubArticleList of that Article are shown, and the grand parent Article's text will collapse again.

The data for the Articles is retrieved through ArticleStore, which gets it's data from an array, but more normally this data would come from a data base.  These components, <ArticleStore, <SubArticleList>, and <Article> are recursively called, the deeper you go. 

You can move through the articles by clicking on the subject to expand/contract each one. You can use the forward and back browser buttons. The URL is updated with every user action, and you can save the URL and go back to it.

The react-proactive-accordion [link] (http://github.com/ddfridley/react-proactive-accordion} is used to encapulate the Article and it's text in order to smooth out their appearance and disappearance.  If things just appear and disappear it takes time for people to recognize what's changed.

If you git fork https://github.com/ddfridley/react-action-state-path you can open the file dist/demo/demo.html .  You can also run 
    node dist/server.js 
to fire up a server. http://localhost:5000

or you can push your repo to heroku:

    heroku create
    heroku config:set NPM_CONFIG_PRODUCTION=false
    git push heroku master

Yhen go to the URL they created for you when you ran heroku create.
You must set NPM_CONFIG_PRODUCTION to false, because other wise npm/heroku won't install the dev dependencies otherwise.

# Usage
component-name.jsx:

    import React from 'react';
    import {ReactActionStatePath, ReactActionStatePathClient} from 'react-action-state-path';

    export default class ComponentName extends React.Component {
        render() {
            return (
                <ReactActionStatePath {...this.props} initialRASP={this.initialRASP} >
                    <RASPComponentName />
                </ReactActionStatePath>
            )
        }
    }

    class RASPComponentName extends ReactActionStatePathClient {
        constructor(props) {
            super(props, 'key' [, debugLevel]);    // the 'key' is the name of the property name used to identify the children. left out it will be 'key'
        }

        segmentToState(action) {  // return the state for the component based on it's action.segment part of the url when starting from a specific URL
            return { nextRASP, setBeforeWait: false };  //setBeforeWait means set the new state and then wait for the key child to appear, otherwise wait for the key child to appear and then set the new state.
        }
        
        actionToState(action, rasp, source, initialRASP) {   // return the next state for the component, based on the action, the current rasp state, the source (PARENT || CHILD), and the initialRASP state;
            var nextRASP={}, delta={};
            if(action.type==="ACTION_NAME"){ 

                action.key // is the identity of the source of the action
                toChild[child-key](action) // will send an action to a child
                
            } else if (...)

            } else 
                return null; // if the action is not know by this component

            // derive this state information in one spot for all actions - it makes it a lot easier to be consistent
            delta.shape= // compute shape. this is the one property of a state that could have meaning to other states. (example: 'open' or 'truncated')
            delta.pathSegment = // compute segment for URL
            Object.assign(nextRASP, rasp, delta);  // return a new state, don't change special properies in the state like depth
            return nextRASP; // return the new state
        }

        render(){
            const {rasp, items, ... } = this.props;
            return(
                {items.map(item->{
                    <Item item={item} rasp={shape: 'initial shape', toParent: this.toMeFromChild.bind(this,item.key)} key={item.key}> // key={} is for react so it can track what's changed
                })}
            )
        }
    }

## action

{   type: "ACTION_NAME",
    [key]: key, the key of the child the originated the action (example _id and an ObjectId)
    shape: the new value of shape from the component that changed shape
    distance: undefined when generated an event by default (like a button click)
              0 : action applies to this component
              1 : action applied to the immediate child
             -n: ignore the action and send it to parent component
    toBeContinued: false/undefined - default
                   true : do not generate a CHILD_SHAP_CHANGED action yet, another action will follow
    [stuff]: children are welcome to include other relevant info in actions
}

These are the inherent actions:

RESET_STATE:  Reset the state of a component, can be sent to a child or a parent
CHILD_SHAPE_CHANGED:  If a child's shape changes, this action is generated and propgated up, with distance increasing each time.  You would use this to reduce, or hide, or change components that are far from the action
CLEAR_PATH:    Reset the state of a component's children, and then the component. (order matters)

# Guidelines

* render children first, then self, then return to parent
* component children that are not in the active path will get their rasp state reset to initialRASP on user navigation
* when sending an action to a parent use setTimeout(()=>this.props.rasp.toParent({type: "ACTION_NAME", distance: -1, ...})) so that the action will take place after the children and the current component have rendered. distance: -2 will skip the immediate parent and go to the grandparent, etc.
* make sure you set the React key of the rendered children.

# Debugging

*When you construct(props) a component, you can super(props,'keyField', debugLevel) to it. If debugLevel is great than 0, messages will print out.  This will cause that component (and it's parent RASP) to print out messages on state changes.
*ReactActionStatePath.thiss[] is available on the browser.  Each RASP and Client component register's it's _this_ in this array.  This makes it really easy to look at the state of things.
*Also you can look at history.pushState.stateStack see to the the state of all the comonents as they have been saved.  The current state is saved each time CHILD_SHAPE_CHANGED propogates to the top.

# To Do

* allow and collect state from orpan components. Right now there can be only one RASP that has no parent. But it could be possible to have orphan components that still use the action to state model, and even collect state from them.  Not sure if they could be in the path though.

* updateHistory should be a direct call to the root rather than a peer to peer call up to the root.

* fold segmentToState into actionToPath it doesn't need to be separate

# Origin story
I created this as I was building in support for the back and forward keys of the browser in a repo for Synaccord that already had a lot going on.  (Children dynamicly selecting children). I looked at redux and react-router but it seemed like a big change and I didn't see an easy way to encode state info in the URL so the user could send a link to the same spot.  react-action-state-path is what evolved and I'm pleased by the simplicity of it and how it's worked in so many components in my code.  

I am sharing it on github in case its useful for anyone else, and I welcome any critical discussion of the concept. It is still evolving.  
